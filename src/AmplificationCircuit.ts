"use strict";

import { IntcodeMachine, IntcodeMachineOptions, Opcode } from "./IntCodeMachine";

export class AmplificationCircuit {
    private readonly _ampCode: bigint[];
    private readonly _amplifiers: {[name: string]: IntcodeMachine};
    private readonly _options: Partial<IntcodeMachineOptions>;
    
    private get _shouldBreak(): boolean { return this._amplifiers['E'].CurrentInstruction === Opcode.BRK; }

    public constructor(ampCode: bigint[], options: Partial<IntcodeMachineOptions> = {}) {
        this._ampCode = ampCode;
        this._amplifiers = {};
        this._options = options;
        ['A', 'B', 'C', 'D', 'E'].forEach((name: string): void => { this._amplifiers[name] = new IntcodeMachine(this._ampCode, options); });
    }

    public ResetCircuits(): void { ['A', 'B', 'C', 'D', 'E'].forEach((name: string): void => { this._amplifiers[name] = new IntcodeMachine(this._ampCode, this._options); }); }

    // Runs amplifiers five times with inputs in phaseSettingSequence
    public CalculateThrust(phaseSettingSequence: number[]): bigint {
        if (phaseSettingSequence.length == 0) { throw new Error("Tried to run an amplifier without a phase setting!"); }        
        
        let signal = 0n;
        ['A','B','C','D','E'].forEach((name: string, index: number): void => {
            this._amplifiers[name].InputValues.push(...[BigInt(phaseSettingSequence[index]), signal]);
            signal = this._amplifiers[name].ExecuteTape().OutputValues[0];
        });
        
        return signal;
    }

    public GetMaxPhaseSettingSequence(isFeedbackEnabled = false): number[] {
        const bestPhaseSettings = { phaseSettingSequence: [], thrust: 0n};
        const permutations = isFeedbackEnabled ? AmplificationCircuit.GeneratePermutations([5, 6, 7, 8, 9]) : AmplificationCircuit.GeneratePermutations([0, 1, 2, 3, 4]);

        permutations.forEach((phaseSettingSequence: number[]): void => {
            const thrust = isFeedbackEnabled ? this.CalculateThrustWithFeedback(phaseSettingSequence) : this.CalculateThrust(phaseSettingSequence);

            if (thrust > bestPhaseSettings.thrust) {
                bestPhaseSettings.phaseSettingSequence = phaseSettingSequence;
                bestPhaseSettings.thrust = thrust;
            }
            this.ResetCircuits();
        });

        return bestPhaseSettings.phaseSettingSequence;
    }

    public CalculateThrustWithFeedback(phaseSettingSequence: number[]): bigint {        
        // Need to execute at least once
        let signal = 0n;
        ['A','B','C','D','E'].forEach((name: string, index: number): void => {
            this._amplifiers[name].InputValues.push(...[BigInt(phaseSettingSequence[index]), signal]);
            signal = this._amplifiers[name].ExecuteTape().OutputValues.shift();
        });

        while (!this._shouldBreak) {
            ['A','B','C','D','E'].forEach((name: string): void => {
                this._amplifiers[name].InputValues.push(signal);
                this._amplifiers[name].ExecuteTape();
                if (this._amplifiers[name].OutputValues.length > 0) { signal = this._amplifiers[name].OutputValues.shift(); }
            });
        }

        return signal;
    }

    private static GeneratePermutations(inputArray: number[]): Array<number[]> {
        const result: Array<number[]> = [];

        const permute = (arr: number[], m: number[] = []): void => {
            if (arr.length ===0) {
                result.push(m);
            } else {
                for (let i = 0; i < arr.length; i++) {
                    const curr = arr.slice();
                    const next = curr.splice(i, 1);
                    permute(curr.slice(), m.concat(next));
                }
            }
        }

        permute(inputArray);
        return result;
    }

    public static Day7Part1(): string {
        const _amplifierCode: bigint[] = [3, 8, 1001, 8, 10, 8, 105, 1, 0, 0, 21, 38, 55, 64, 81, 106, 187, 268, 349, 430, 99999, 3, 9, 101, 2, 9, 9, 1002, 9, 2, 9, 101, 5, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 101, 3, 9, 9, 1002, 9, 4, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 5, 9, 1001, 9, 4, 9, 102, 4, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 1001, 9, 5, 9, 102, 3, 9, 9, 1001, 9, 4, 9, 102, 5, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 99, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 99].map((val: number): bigint => BigInt(val));
        
        const circuit = new AmplificationCircuit(_amplifierCode, { SilentMode: true });
        const maxPhaseSettingSequence = circuit.GetMaxPhaseSettingSequence();
        const thrust = circuit.CalculateThrust(maxPhaseSettingSequence);
        return thrust.toString();
    }

    public static Day7Part2(): string {
        const _amplifierCode: bigint[] = [3, 8, 1001, 8, 10, 8, 105, 1, 0, 0, 21, 38, 55, 64, 81, 106, 187, 268, 349, 430, 99999, 3, 9, 101, 2, 9, 9, 1002, 9, 2, 9, 101, 5, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 101, 3, 9, 9, 1002, 9, 4, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 5, 9, 1001, 9, 4, 9, 102, 4, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 1001, 9, 5, 9, 102, 3, 9, 9, 1001, 9, 4, 9, 102, 5, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 99, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 99].map((val: number): bigint => BigInt(val));
        
        const circuit = new AmplificationCircuit(_amplifierCode, { BreakOnOutput: true, SilentMode: true });
        const maxPhaseSettingSequence = circuit.GetMaxPhaseSettingSequence(true);
        const thrust = circuit.CalculateThrustWithFeedback(maxPhaseSettingSequence);
        return thrust.toString();
    }
}